## 寻找数组的中心索引

## 1. 题目描述

给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。

我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

示例1：

```
输入: 
nums = [1, 7, 3, 6, 5, 6]
输出: 3
解释: 
索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。
同时, 3 也是第一个符合要求的中心索引。
```

示例2：

```
输入: 
nums = [1, 2, 3]
输出: -1
解释: 
数组中不存在满足此条件的中心索引。
```

说明：

-   `nums` 的长度范围为 `[0, 10000]`。
-   任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。

## 2. 解题思路

以 `[1, 7, 3, 6, 5, 6]` 为例，`6` 为中心索引为 `i` 的元素 `j`，左侧和 `left_sum` 为 11，右侧和 `right_sum` 也为 11。

所以可以将数组表示为 `[left_sum, j, right_sum]` ，而且`left_sum` = `right_sum` ，设数组所有元素和为 `total` ，则有式子 `2*left_sum + j = total` 成立，以此条件判断是否为中心索引。

## 3.代码

```python
def pivotIndex_better(nums):
    total = sum(nums)
    left_sum = 0
    for i, j in enumerate(nums):
        if 2*left_sum + j == total:
            return i
        left_sum += j
    return -1
```

## 4.代码说明

利用 `enumerate(nums)` 获取数组的索引元素对，并用累加的方法求左侧和，而不是用 `nums[:i]` 方式。

因为`nums[:i]` 调用了python对C语言的封装，而底层也是累加的形式，比直接用 `left_sum += j` 效率低，而且是在循环里，更加拖慢效率。

注：在循环里应尽量少的使用函数调用，简单优于复杂。


