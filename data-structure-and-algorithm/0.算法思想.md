## 一、哨兵思想

典型用例：快排、查找、链表。

顾名思义，哨兵有看守监督的功能，一般哨兵不会在程序里充当操作对象，而是作为比较对象或边界缓冲对象，用于简化或规范统一对操作对象的操作。

#### 例一：在数组a中，按值查找key，返回key所在的位置

```c
// 不使用哨兵
// 其中，n表示数组a的长度
int find(char* a, int n, char key) {
  // 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
  if(a == NULL || n <= 0) {
    return -1;
  }
  
  int i = 0;
  // 这里有两个比较操作：i<n和a[i]==key.
  while (i < n) {
    if (a[i] == key) {
      return i;
    }
    ++i;
  }
  
  return -1;
}

// 使用哨兵
// a = {'a', 'b', 'c', 'd', 'e'};  n=5 key = 'f'
// a = {'a', 'b', 'c', 'd', 'e'};  n=5 key = 'd'
int find(char* a, int n, char key) {
  if(a == NULL || n <= 0) {
    return -1;
  }
  
  // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }
  
  // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
  char tmp = a[n-1];
  // 把key的值放到a[n-1]中，此时a = {'a', 'b', 'c', 'd', 'f'}
  a[n-1] = key;
  
  int i = 0;
  // 这里是主要代码 **************************
  // while 循环比起不使用哨兵，少了i<n这个比较操作
  // 在持续运行的程序中，这将大大节省时间
  while (a[i] != key) {
    ++i;
  }
  
  // 恢复a[n-1]原来的值,此时a= {'a', 'b', 'c', 'd', 'e'}
  a[n-1] = tmp;
  
  if (i == n-1) {
    // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
    return -1;
  } else {
    // 否则，返回i，就是等于key值的元素的下标
    return i;
  }
}
```

#### 例二：链表中对节点的统一操作

在链表中，对节点的操作，要分链表的头部，中间和尾部，不同位置的节点要分别处理，这大大增加了代码量和复杂度。

但如果使用哨兵节点（也叫头结点），可以统一这些操作。

参考：

> http://c.biancheng.net/view/3336.html
>
> https://time.geekbang.org/column/article/41149



## 二、套娃思想

典型用例：内存分页机制映射寻址、多体存储器寻址（一般和地址寻址相关的场景都用到了这一思想）。

顾名思义，套娃就是一层套一层，一级套一级，就像地址一样，xx省xx市xx县xx街道xx小区xx栋xx单元xx一样，然后用二进制表示。**重点是将他们分级，可以高效寻址。**

举个例子，有0到7共8个单元，如果这8个单元同级，要访问他们，最坏的时间复杂度为O(n)，但若把它们分级，比如

用二进制表示需要4位，



## 三、中间层思想